\section{Preliminary}
\label{sec:perliminary}

In this section, we will introduce the essential notations, problem definitions and background knowledge of rumor tracking. The frequently used notations are summarized in Table. \ref{tab:notations}

\begin{table}[tbp]
	\caption{Notation Summarization}
	\centering
	\label{tab:notations}
	\resizebox{0.45\linewidth}{!}{
		\begin{tabular}{|l|l|}
			\hline
			\textbf{Notation} & \textbf{Definition} \\
			\hline
			$T$ & the set of tweets\\
			\hline
			$t_n$ & a tweet\\
			\hline
			$C$ & the set of rumor events\\
			\hline
			$c_m$ & a rumor event\\
			\hline					
		\end{tabular}
	}	
\end{table}

\subsection{Social Network Data}
We use benchmark dataset PHEME \cite{DBLP:conf/coling/KochkinaLZ18} and RumorEval\cite{DBLP:conf/semeval/EnayetE17} from twitter. The data format is shown in Fig. x. As we can see, a tweet thread is a source tweet with all its retweets and comments. These retweets and comments from several branches, which seems like a tree structure. A tweet branch consists of a series of tweets.

\subsection{Problem Definition}
\label{sec:problem}
Let $T = \left\{t_1, t_2, ..., t_n \right\}$ denote the set of tweets and each tweet is denoted as $t_n$. Let $C = \left\{c_1, c_2, ... , c_m \right\}$ denote the set of rumor events and $c_m$ denotes a particular rumor event. Each tweet is only assigned with one rumor event. For each given tweet $t_n$, the goal of rumor tracking is to find the most likely relevant event of it. Also, for a testing sample, we will not get any information about its branch or threads in advance. 

\subsection{Aggregated Model}
